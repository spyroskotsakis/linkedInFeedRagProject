# langchain_experimental.rl_chain.metrics â€” ðŸ¦œðŸ”— LangChain  documentation

**URL:** https://python.langchain.com/api_reference/_modules/langchain_experimental/rl_chain/metrics.html
**Word Count:** 10
**Links Count:** 22
**Scraped:** 2025-07-21 09:19:50
**Status:** completed

---

# Source code for langchain\_experimental.rl\_chain.metrics               from collections import deque     from typing import TYPE_CHECKING, Dict, List, Union          if TYPE_CHECKING:         import pandas as pd                              [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.html#langchain_experimental.rl_chain.metrics.MetricsTrackerAverage)     class MetricsTrackerAverage:         """Metrics Tracker Average."""                         [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.html#langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.__init__)         def __init__(self, step: int):             self.history: List[Dict[str, Union[int, float]]] = [{"step": 0, "score": 0}]             self.step: int = step             self.i: int = 0             self.num: float = 0             self.denom: float = 0                             @property         def score(self) -> float:             return self.num / self.denom if self.denom > 0 else 0                         [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.html#langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.on_decision)         def on_decision(self) -> None:             self.denom += 1                                        [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.html#langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.on_feedback)         def on_feedback(self, score: float) -> None:             self.num += score or 0             self.i += 1             if self.step > 0 and self.i % self.step == 0:                 self.history.append({"step": self.i, "score": self.score})                                        [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.html#langchain_experimental.rl_chain.metrics.MetricsTrackerAverage.to_pandas)         def to_pandas(self) -> "pd.DataFrame":             import pandas as pd                  return pd.DataFrame(self.history)                                                            [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.html#langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow)     class MetricsTrackerRollingWindow:         """Metrics Tracker Rolling Window."""                         [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.html#langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.__init__)         def __init__(self, window_size: int, step: int):             self.history: List[Dict[str, Union[int, float]]] = [{"step": 0, "score": 0}]             self.step: int = step             self.i: int = 0             self.window_size: int = window_size             self.queue: deque = deque()             self.sum: float = 0.0                             @property         def score(self) -> float:             return self.sum / len(self.queue) if len(self.queue) > 0 else 0                         [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.html#langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.on_decision)         def on_decision(self) -> None:             pass                                        [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.html#langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.on_feedback)         def on_feedback(self, value: float) -> None:             self.sum += value             self.queue.append(value)             self.i += 1                  if len(self.queue) > self.window_size:                 old_val = self.queue.popleft()                 self.sum -= old_val                  if self.step > 0 and self.i % self.step == 0:                 self.history.append({"step": self.i, "score": self.sum / len(self.queue)})                                        [[docs]](https://python.langchain.com/api_reference/experimental/rl_chain/langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.html#langchain_experimental.rl_chain.metrics.MetricsTrackerRollingWindow.to_pandas)         def to_pandas(self) -> "pd.DataFrame":             import pandas as pd                  return pd.DataFrame(self.history)