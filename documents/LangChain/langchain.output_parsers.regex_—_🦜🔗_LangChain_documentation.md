# langchain.output_parsers.regex â€” ðŸ¦œðŸ”— LangChain  documentation

**URL:** https://python.langchain.com/api_reference/_modules/langchain/output_parsers/regex.html
**Word Count:** 46
**Links Count:** 14
**Scraped:** 2025-07-21 07:58:09
**Status:** completed

---

# Source code for langchain.output\_parsers.regex               from __future__ import annotations          import re     from typing import Optional          from langchain_core.output_parsers import BaseOutputParser                              [[docs]](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.regex.RegexParser.html#langchain.output_parsers.regex.RegexParser)     class RegexParser(BaseOutputParser[dict[str, str]]):         """Parse the output of an LLM call using a regex."""              @classmethod         def is_lc_serializable(cls) -> bool:             return True              regex: str         """The regex to use to parse the output."""         output_keys: list[str]         """The keys to use for the output."""         default_output_key: Optional[str] = None         """The default key to use for the output."""              @property         def _type(self) -> str:             """Return the type key."""             return "regex_parser"                         [[docs]](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.regex.RegexParser.html#langchain.output_parsers.regex.RegexParser.parse)         def parse(self, text: str) -> dict[str, str]:             """Parse the output of an LLM call."""             match = re.search(self.regex, text)             if match:                 return {key: match.group(i + 1) for i, key in enumerate(self.output_keys)}             if self.default_output_key is None:                 msg = f"Could not parse output: {text}"                 raise ValueError(msg)             return {                 key: text if key == self.default_output_key else ""                 for key in self.output_keys             }