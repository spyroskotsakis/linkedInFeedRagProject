# langchain.chains.router.embedding_router â€” ðŸ¦œðŸ”— LangChain  documentation

**URL:** https://python.langchain.com/api_reference/_modules/langchain/chains/router/embedding_router.html
**Word Count:** 25
**Links Count:** 15
**Scraped:** 2025-07-21 07:57:21
**Status:** completed

---

# Source code for langchain.chains.router.embedding\_router               from __future__ import annotations          from collections.abc import Sequence     from typing import Any, Optional          from langchain_core.callbacks import (         AsyncCallbackManagerForChainRun,         CallbackManagerForChainRun,     )     from langchain_core.documents import Document     from langchain_core.embeddings import Embeddings     from langchain_core.vectorstores import VectorStore     from pydantic import ConfigDict          from langchain.chains.router.base import RouterChain                              [[docs]](https://python.langchain.com/api_reference/langchain/chains/langchain.chains.router.embedding_router.EmbeddingRouterChain.html#langchain.chains.router.embedding_router.EmbeddingRouterChain)     class EmbeddingRouterChain(RouterChain):         """Chain that uses embeddings to route between options."""              vectorstore: VectorStore         routing_keys: list[str] = ["query"]              model_config = ConfigDict(             arbitrary_types_allowed=True,             extra="forbid",         )              @property         def input_keys(self) -> list[str]:             """Will be whatever keys the LLM chain prompt expects.                  :meta private:             """             return self.routing_keys              def _call(             self,             inputs: dict[str, Any],             run_manager: Optional[CallbackManagerForChainRun] = None,         ) -> dict[str, Any]:             _input = ", ".join([inputs[k] for k in self.routing_keys])             results = self.vectorstore.similarity_search(_input, k=1)             return {"next_inputs": inputs, "destination": results[0].metadata["name"]}              async def _acall(             self,             inputs: dict[str, Any],             run_manager: Optional[AsyncCallbackManagerForChainRun] = None,         ) -> dict[str, Any]:             _input = ", ".join([inputs[k] for k in self.routing_keys])             results = await self.vectorstore.asimilarity_search(_input, k=1)             return {"next_inputs": inputs, "destination": results[0].metadata["name"]}                         [[docs]](https://python.langchain.com/api_reference/langchain/chains/langchain.chains.router.embedding_router.EmbeddingRouterChain.html#langchain.chains.router.embedding_router.EmbeddingRouterChain.from_names_and_descriptions)         @classmethod         def from_names_and_descriptions(             cls,             names_and_descriptions: Sequence[tuple[str, Sequence[str]]],             vectorstore_cls: type[VectorStore],             embeddings: Embeddings,             **kwargs: Any,         ) -> EmbeddingRouterChain:             """Convenience constructor."""             documents = []             for name, descriptions in names_and_descriptions:                 documents.extend(                     [                         Document(page_content=description, metadata={"name": name})                         for description in descriptions                     ]                 )             vectorstore = vectorstore_cls.from_documents(documents, embeddings)             return cls(vectorstore=vectorstore, **kwargs)                                        [[docs]](https://python.langchain.com/api_reference/langchain/chains/langchain.chains.router.embedding_router.EmbeddingRouterChain.html#langchain.chains.router.embedding_router.EmbeddingRouterChain.afrom_names_and_descriptions)         @classmethod         async def afrom_names_and_descriptions(             cls,             names_and_descriptions: Sequence[tuple[str, Sequence[str]]],             vectorstore_cls: type[VectorStore],             embeddings: Embeddings,             **kwargs: Any,         ) -> EmbeddingRouterChain:             """Convenience constructor."""             documents = []             documents.extend(                 [                     Document(page_content=description, metadata={"name": name})                     for name, descriptions in names_and_descriptions                     for description in descriptions                 ]             )             vectorstore = await vectorstore_cls.afrom_documents(documents, embeddings)             return cls(vectorstore=vectorstore, **kwargs)