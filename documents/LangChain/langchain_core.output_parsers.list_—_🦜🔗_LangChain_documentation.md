# langchain_core.output_parsers.list â€” ðŸ¦œðŸ”— LangChain  documentation

**URL:** https://python.langchain.com/api_reference/_modules/langchain_core/output_parsers/list.html
**Word Count:** 334
**Links Count:** 27
**Scraped:** 2025-07-21 08:57:11
**Status:** completed

---

# Source code for langchain\_core.output\_parsers.list               """Parsers for list output."""          from __future__ import annotations          import csv     import re     from abc import abstractmethod     from collections import deque     from io import StringIO     from typing import TYPE_CHECKING, TypeVar, Union          from typing_extensions import override          from langchain_core.messages import BaseMessage     from langchain_core.output_parsers.transform import BaseTransformOutputParser          if TYPE_CHECKING:         from collections.abc import AsyncIterator, Iterator          T = TypeVar("T")                              [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.droplastn.html#langchain_core.output_parsers.list.droplastn)     def droplastn(         iter: Iterator[T],  # noqa: A002         n: int,     ) -> Iterator[T]:         """Drop the last n elements of an iterator.              Args:             iter: The iterator to drop elements from.             n: The number of elements to drop.              Yields:             The elements of the iterator, except the last n elements.         """         buffer: deque[T] = deque()         for item in iter:             buffer.append(item)             if len(buffer) > n:                 yield buffer.popleft()                                             [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.ListOutputParser.html#langchain_core.output_parsers.list.ListOutputParser)     class ListOutputParser(BaseTransformOutputParser[list[str]]):         """Parse the output of an LLM call to a list."""              @property         def _type(self) -> str:             return "list"                         [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.ListOutputParser.html#langchain_core.output_parsers.list.ListOutputParser.parse)         @abstractmethod         def parse(self, text: str) -> list[str]:             """Parse the output of an LLM call.                  Args:                 text: The output of an LLM call.                  Returns:                 A list of strings.             """                                        [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.ListOutputParser.html#langchain_core.output_parsers.list.ListOutputParser.parse_iter)         def parse_iter(self, text: str) -> Iterator[re.Match]:             """Parse the output of an LLM call.                  Args:                 text: The output of an LLM call.                  Yields:                 A match object for each part of the output.             """             raise NotImplementedError                             @override         def _transform(             self, input: Iterator[Union[str, BaseMessage]]         ) -> Iterator[list[str]]:             buffer = ""             for chunk in input:                 if isinstance(chunk, BaseMessage):                     # extract text                     chunk_content = chunk.content                     if not isinstance(chunk_content, str):                         continue                     buffer += chunk_content                 else:                     # add current chunk to buffer                     buffer += chunk                 # parse buffer into a list of parts                 try:                     done_idx = 0                     # yield only complete parts                     for m in droplastn(self.parse_iter(buffer), 1):                         done_idx = m.end()                         yield [m.group(1)]                     buffer = buffer[done_idx:]                 except NotImplementedError:                     parts = self.parse(buffer)                     # yield only complete parts                     if len(parts) > 1:                         for part in parts[:-1]:                             yield [part]                         buffer = parts[-1]             # yield the last part             for part in self.parse(buffer):                 yield [part]              @override         async def _atransform(             self, input: AsyncIterator[Union[str, BaseMessage]]         ) -> AsyncIterator[list[str]]:             buffer = ""             async for chunk in input:                 if isinstance(chunk, BaseMessage):                     # extract text                     chunk_content = chunk.content                     if not isinstance(chunk_content, str):                         continue                     buffer += chunk_content                 else:                     # add current chunk to buffer                     buffer += chunk                 # parse buffer into a list of parts                 try:                     done_idx = 0                     # yield only complete parts                     for m in droplastn(self.parse_iter(buffer), 1):                         done_idx = m.end()                         yield [m.group(1)]                     buffer = buffer[done_idx:]                 except NotImplementedError:                     parts = self.parse(buffer)                     # yield only complete parts                     if len(parts) > 1:                         for part in parts[:-1]:                             yield [part]                         buffer = parts[-1]             # yield the last part             for part in self.parse(buffer):                 yield [part]                                             [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.CommaSeparatedListOutputParser.html#langchain_core.output_parsers.list.CommaSeparatedListOutputParser)     class CommaSeparatedListOutputParser(ListOutputParser):         """Parse the output of an LLM call to a comma-separated list."""              @classmethod         def is_lc_serializable(cls) -> bool:             """Check if the langchain object is serializable.                  Returns True.             """             return True              @classmethod         def get_lc_namespace(cls) -> list[str]:             """Get the namespace of the langchain object.                  Returns:                 A list of strings.                 Default is ["langchain", "output_parsers", "list"].             """             return ["langchain", "output_parsers", "list"]                         [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.CommaSeparatedListOutputParser.html#langchain_core.output_parsers.list.CommaSeparatedListOutputParser.get_format_instructions)         def get_format_instructions(self) -> str:             """Return the format instructions for the comma-separated list output."""             return (                 "Your response should be a list of comma separated values, "                 "eg: `foo, bar, baz` or `foo,bar,baz`"             )                                        [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.CommaSeparatedListOutputParser.html#langchain_core.output_parsers.list.CommaSeparatedListOutputParser.parse)         def parse(self, text: str) -> list[str]:             """Parse the output of an LLM call.                  Args:                 text: The output of an LLM call.                  Returns:                 A list of strings.             """             try:                 reader = csv.reader(                     StringIO(text), quotechar='"', delimiter=",", skipinitialspace=True                 )                 return [item for sublist in reader for item in sublist]             except csv.Error:                 # keep old logic for backup                 return [part.strip() for part in text.split(",")]                             @property         def _type(self) -> str:             return "comma-separated-list"                                             [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.NumberedListOutputParser.html#langchain_core.output_parsers.list.NumberedListOutputParser)     class NumberedListOutputParser(ListOutputParser):         """Parse a numbered list."""              pattern: str = r"\d+\.\s([^\n]+)"         """The pattern to match a numbered list item."""                         [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.NumberedListOutputParser.html#langchain_core.output_parsers.list.NumberedListOutputParser.get_format_instructions)         @override         def get_format_instructions(self) -> str:             return (                 "Your response should be a numbered list with each item on a new line. "                 "For example: \n\n1. foo\n\n2. bar\n\n3. baz"             )                                        [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.NumberedListOutputParser.html#langchain_core.output_parsers.list.NumberedListOutputParser.parse)         def parse(self, text: str) -> list[str]:             """Parse the output of an LLM call.                  Args:                 text: The output of an LLM call.                  Returns:                 A list of strings.             """             return re.findall(self.pattern, text)                                        [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.NumberedListOutputParser.html#langchain_core.output_parsers.list.NumberedListOutputParser.parse_iter)         def parse_iter(self, text: str) -> Iterator[re.Match]:             """Parse the output of an LLM call.                  Args:                 text: The output of an LLM call.                  Yields:                 A match object for each part of the output.             """             return re.finditer(self.pattern, text)                             @property         def _type(self) -> str:             return "numbered-list"                                             [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.MarkdownListOutputParser.html#langchain_core.output_parsers.list.MarkdownListOutputParser)     class MarkdownListOutputParser(ListOutputParser):         """Parse a Markdown list."""              pattern: str = r"^\s*[-*]\s([^\n]+)$"         """The pattern to match a Markdown list item."""                         [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.MarkdownListOutputParser.html#langchain_core.output_parsers.list.MarkdownListOutputParser.get_format_instructions)         def get_format_instructions(self) -> str:             """Return the format instructions for the Markdown list output."""             return "Your response should be a markdown list, eg: `- foo\n- bar\n- baz`"                                        [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.MarkdownListOutputParser.html#langchain_core.output_parsers.list.MarkdownListOutputParser.parse)         def parse(self, text: str) -> list[str]:             """Parse the output of an LLM call.                  Args:                 text: The output of an LLM call.                  Returns:                 A list of strings.             """             return re.findall(self.pattern, text, re.MULTILINE)                                        [[docs]](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.list.MarkdownListOutputParser.html#langchain_core.output_parsers.list.MarkdownListOutputParser.parse_iter)         def parse_iter(self, text: str) -> Iterator[re.Match]:             """Parse the output of an LLM call.                  Args:                 text: The output of an LLM call.                  Yields:                 A match object for each part of the output.             """             return re.finditer(self.pattern, text, re.MULTILINE)                             @property         def _type(self) -> str:             return "markdown-list"