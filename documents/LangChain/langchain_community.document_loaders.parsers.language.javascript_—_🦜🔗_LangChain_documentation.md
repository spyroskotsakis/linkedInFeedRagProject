# langchain_community.document_loaders.parsers.language.javascript â€” ðŸ¦œðŸ”— LangChain  documentation

**URL:** https://python.langchain.com/api_reference/_modules/langchain_community/document_loaders/parsers/language/javascript.html
**Word Count:** 24
**Links Count:** 17
**Scraped:** 2025-07-21 09:17:38
**Status:** completed

---

# Source code for langchain\_community.document\_loaders.parsers.language.javascript               from typing import Any, List, Tuple          from langchain_community.document_loaders.parsers.language.code_segmenter import (         CodeSegmenter,     )                              [[docs]](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.html#langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter)     class JavaScriptSegmenter(CodeSegmenter):         """Code segmenter for JavaScript."""                         [[docs]](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.html#langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.__init__)         def __init__(self, code: str):             super().__init__(code)             self.source_lines = self.code.splitlines()                  try:                 import esprima  # noqa: F401             except ImportError:                 raise ImportError(                     "Could not import esprima Python package. "                     "Please install it with `pip install esprima`."                 )                                        [[docs]](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.html#langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.is_valid)         def is_valid(self) -> bool:             import esprima                  try:                 esprima.parseScript(self.code)                 return True             except esprima.Error:                 return False                             def _extract_code(self, node: Any) -> str:             start = node.loc.start.line - 1             end = node.loc.end.line             return "\n".join(self.source_lines[start:end])                         [[docs]](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.html#langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.extract_functions_classes)         def extract_functions_classes(self) -> List[str]:             import esprima                  tree = esprima.parseScript(self.code, loc=True)             functions_classes = []                  for node in tree.body:                 if isinstance(                     node,                     (esprima.nodes.FunctionDeclaration, esprima.nodes.ClassDeclaration),                 ):                     functions_classes.append(self._extract_code(node))                  return functions_classes                                        [[docs]](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.html#langchain_community.document_loaders.parsers.language.javascript.JavaScriptSegmenter.simplify_code)         def simplify_code(self) -> str:             import esprima                  tree = esprima.parseScript(self.code, loc=True)             simplified_lines = self.source_lines[:]                  indices_to_del: List[Tuple[int, int]] = []             for node in tree.body:                 if isinstance(                     node,                     (esprima.nodes.FunctionDeclaration, esprima.nodes.ClassDeclaration),                 ):                     start, end = node.loc.start.line - 1, node.loc.end.line                     simplified_lines[start] = f"// Code for: {simplified_lines[start]}"                          indices_to_del.append((start + 1, end))                  for start, end in reversed(indices_to_del):                 del simplified_lines[start + 0 : end]                  return "\n".join(line for line in simplified_lines)