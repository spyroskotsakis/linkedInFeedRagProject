# langchain_community.tools.file_management.list_dir â€” ðŸ¦œðŸ”— LangChain  documentation

**URL:** https://python.langchain.com/api_reference/_modules/langchain_community/tools/file_management/list_dir.html
**Word Count:** 34
**Links Count:** 14
**Scraped:** 2025-07-21 09:13:00
**Status:** completed

---

# Source code for langchain\_community.tools.file\_management.list\_dir               import os     from typing import Optional, Type          from langchain_core.callbacks import CallbackManagerForToolRun     from langchain_core.tools import BaseTool     from pydantic import BaseModel, Field          from langchain_community.tools.file_management.utils import (         INVALID_PATH_TEMPLATE,         BaseFileToolMixin,         FileValidationError,     )                              [[docs]](https://python.langchain.com/api_reference/community/tools/langchain_community.tools.file_management.list_dir.DirectoryListingInput.html#langchain_community.tools.file_management.list_dir.DirectoryListingInput)     class DirectoryListingInput(BaseModel):         """Input for ListDirectoryTool."""              dir_path: str = Field(default=".", description="Subdirectory to list.")                                             [[docs]](https://python.langchain.com/api_reference/community/tools/langchain_community.tools.file_management.list_dir.ListDirectoryTool.html#langchain_community.tools.file_management.list_dir.ListDirectoryTool)     class ListDirectoryTool(BaseFileToolMixin, BaseTool):         """Tool that lists files and directories in a specified folder."""              name: str = "list_directory"         args_schema: Type[BaseModel] = DirectoryListingInput         description: str = "List files and directories in a specified folder"              def _run(             self,             dir_path: str = ".",             run_manager: Optional[CallbackManagerForToolRun] = None,         ) -> str:             try:                 dir_path_ = self.get_relative_path(dir_path)             except FileValidationError:                 return INVALID_PATH_TEMPLATE.format(arg_name="dir_path", value=dir_path)             try:                 entries = os.listdir(dir_path_)                 if entries:                     return "\n".join(entries)                 else:                     return f"No files found in directory {dir_path}"             except Exception as e:                 return "Error: " + str(e)                             # TODO: Add aiofiles method